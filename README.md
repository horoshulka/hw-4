
Ответ на вопрос 4:
Мемоизация — это техника оптимизации, которая заключается в сохранении результатов выполнения функций для последующего использования, чтобы избежать повторных вычислений для одних и тех же входных данных. Она особенно полезна для рекурсивных алгоритмов с повторяющимися вызовами.

Как мемоизация помогает оптимизировать рекурсивные алгоритмы:

1. Снижение временной сложности: Например, в наивной реализации Фибоначчи сложность O(2ⁿ), а с мемоизацией — O(n).
2. Устранение избыточных вычислений: Результаты записываются в кэш (например, словарь или массив) и переиспользуются.
3. Пример для Фибоначчи:
   def fibonacci(n, memo={}):
       if n in memo:
           return memo[n]
       if n <= 1:
           return n
       memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
       return memo[n]
   Результат: Мемоизация превращает экспоненциальную сложность в линейную, экономя вычислительные ресурсы.

Вариант 16
Алгоритм работает рекурсивно, посещая каждый узел дерева.
Временная сложность каждого обхода
О(n), где п - количество узлов, потому что мы посещаем каждый узел ровно один раз. Пространственная сложность O(h) в худшем случае (где h
- высота дерева) из-за стека рекурсивных вызовов.
Различия между видами обхода:
﻿﻿Preorder: узел обрабатывается до своих дочерних узлов. Используется для создания копии дерева или сериализации.
﻿﻿Inorder: для бинарного дерева поиска
(BST) выводит узлы в отсортированном порядке.
Postorder: узел обрабатывается после своих дочерних узлов.
Используется для удаления дерева или вычисления выражений.

Python:
﻿﻿Используется класс TreeNode для представления узла.
﻿﻿Рекурсивные функции проверяют, не является ли узел None.
﻿﻿Простой синтаксис, нет точек с запятой, автоматическое управление памятью.
Временная сложность: O(n) - посещаем каждый узел ровно один раз
Java:
﻿﻿Класс TreeNode с полями left и right.
﻿﻿Рекурсивные методы статические, проверка на null.
﻿﻿Управление памятью с помощью сборщика мусора.
Временная сложность: O(n) - каждый узел обрабатывается один раз

C++:
﻿﻿Структура TreeNode с указателями
на left и right.
﻿﻿Рекурсивные функции принимают указатели, проверка на nullptr.
﻿﻿Необходимо вручную освобождать память (в коде добавлена функция
deleteTree).
Временная сложность: O(n) - линейная зависимость от количества узлов

Основные различия между языками:
﻿﻿B Python и Java управление памятью автоматическое, в С++ - ручное.
﻿﻿В С++ используются указатели и оператор -> для доступа к полям, в
Python и Java - ссылки и оператор '!.
﻿﻿В Python динамическая типизация, в
Java и C++ - статическая.
Вывод: алгоритм обхода дерева реализуется похожим образом на всех трех языках, но с учетом особенностей
синтаксиса и управления памятью.
